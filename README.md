# pg_integration. Подсистема репликации и интеграции данных.

## Назначение.
Ручная настройка специфических сценариев обмена данными между таблицами, базами данных и серверами СУБД. Объединяет все эти сценарии общий подход к механизму передачи данных из источника в приемник:
- формирование шаблонных команд INSERT, UPDATE и DELETE на основе настроек метаданных, учитывающих различные ситуации:
  - данных нет в приемнике;
  - данных нет в источнике;
  - данные сопоставлены по ключевым полям, но различаются по неключевым.
- журналирование процесса передачи данных.

## Установка.
### Вариант 1.
Распаковать расширение в отдельный каталог.

Вызвать команду:
```
sudo make install
```
Затем в СУБД:
```
create extension pg_integrations;
```
### Вариант 2.
Вручную скопировать все файлы, кроме Makefile, в каталог **SHAREDIR**/extension/. SHAREDIR уточнять через утилиту pg_config.

Затем в СУБД:
```
create extension pg_integrations;
```

## Использование (примеры).

Есть два сервера СУБД на разных компьютерах:
- server1. Источник, генерирующий данные.
- server2. Потребитель данных источника.
Задача: синхронизировать данные, т.е. передавать их из таблицы на server1 в таблицу server2.

Сначала владелец или администратор server1 должен предоставить информацию для подключения к server1: адрес сервера, имя экземпляра, порт и т.д. Кроме этого необходимо получить название БД, таблицы (детальные описания колонок) и соответствующие права чтения.

Например, мы хотим реплицировать следующую таблицу на стороне источника:
```
create table Test (
	i int primary key generated always as identity, 
	ts timestamp default (now()), 
	txt text
);
insert into Test select 'Hello, ';
insert into Test select 'World!';
```

На принимающей стороне таблица должна иметь аналогичную структуру, но желательно без ограничений колонок.
```
create table Test (
	i int, 
	ts timestamp, 
	txt text
);
```

На основе полученной информации на server2 создается внешний сервер (через fdw), реализующий подключение к server1. Например, сервер будет иметь имя **server1**. А внешняя таблица будет иметь название **test**. (_Но на самом деле роль источника данных может играть не только внешний сервер, а, например, другая локальная таблица, или заранее подготовленная временная в этой же сессии таблица._)

Потом в конфигурационной таблице дается описание объекта данных:
```
insert into dbo.DataObject(name,SourceName,DestinationName) 
values ('Test','server1.test','test');
```

Затем необходимо описать колонки, которые надо передавать из источника в приемник:
```
insert into dbo.DataAttributes(DataObject_id, SourceName,DestinationName,IsUnique,IsTimestamp)
values (1, 'i','i', 1, 0), (1, 'ts','ts', 0, 1), (1, 'txt','txt', 0, 0)
```

Метка **IsUnique** необходима для того, чтобы с помощью уникальности ключевых атрибутов отбросить дубликаты записей, если они есть на стороне источника.

Метка **IsTimestamp** необходима для того, чтобы ограничить запрос данных определенным временным интервалом. Иначе запрос данных скорее всего будет возвращать **ВСЕ** записи из источника.

Должно быть как минимум по одной колонке с меткой IsUnique и IsTimestamp.

## Запуск

Для запуска интеграции используется хранимая процедура, в которую передается id объекта данных:
```
call integrations.usp_runIntegration 1
```

В таблицах Log и LogDetails содержится вся информация о ходе интеграции. Если возникла ошибка, то в целях отладки можно получить текст всего сгенерированного скрипта импорта данных:
```
exec usp_runIntegration 1, @verbose = 2
```
